{%
   include-markdown "common.md"
   start="<!--out-of-date-start-->"
   end="<!--out-of-date-stop-->"
   comments=false
%}

# Compliant Kubernetes Deployment on Exoscale

This document contains instructions on how to setup a service cluster and a workload cluster in Exoscale.
The following are the main tasks addressed in this document:

1. Infrastructure setup for two clusters: one service and one workload cluster
1. Deploying Compliant Kubernetes on top of the two clusters.
1. Creating DNS Records
1. Deploying Rook Storage Orchestration Service
1. Deploying Compliant Kubernetes apps

The instructions below are just samples, you need to update them according to your requirements.
Besides, the [exoscale cli](https://github.com/exoscale/cli/releases) is used to manage DNS.
If you are using any other DNS service provider for managing your DNS you can skip it.

Before starting, make sure you have [all necessary tools](getting-started.md).

!!!note
    This guide is written for compliantkubernetes-apps [v0.17.0](https://github.com/elastisys/compliantkubernetes-apps/tree/v0.17.0)

## Setup

Choose names for your service cluster and workload cluster, as well as a name for your environment:

```bash
SERVICE_CLUSTER="testsc"
WORKLOAD_CLUSTERS=( "testwc0" )
CK8S_ENVIRONMENT_NAME=my-environment-name
```

## Infrastructure Setup using Terraform

Before trying any of the steps, clone the Elastisys Compliant Kubernetes Kubespray repo as follows:

```bash
git clone --recursive https://github.com/elastisys/compliantkubernetes-kubespray
cd compliantkubernetes-kubespray/kubespray
```

### Expose Exoscale credentials to Terraform

For authentication create the file  `~/.cloudstack.ini` and put your Exoscale credentials in it.
The file should look like something like this:

```
[cloudstack]
key = <API key>
secret = <API secret>
```

### Customize your infrastructure

Create a configuration for the service and the workload clusters:

```bash
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
  cp -r inventory/sample inventory/$CLUSTER
  cp contrib/terraform/exoscale/default.tfvars inventory/$CLUSTER/
done
```

Review and, if needed, adjust the files in `inventory/$CLUSTER/default.tfvars`, where `$CLUSTER` is the cluster name:

* Use different value for the `prefix` field in `/default.tfvars` for the two clusters.
    Failing to do so will result in a name conflict.
* Set a non-zero value for `ceph_partition_size` field, e.g., `"ceph_partition_size": 50`, as it will be used by Rook storage service to provide local disk storage.
* To security harden your cluster, set `ssh_whitelist` and `api_server_whitelist` to the IP addresses from which you expect to operate the cluster.
* Make sure you configure your SSH keys in `ssh_public_keys`.

!!!important

    The `Linux Ubuntu 20.04 LTS 64-bit` image on Exoscale is regularly upgraded, which might cause unexpected changes during `terraform apply`. Consider uploading your own dated Ubuntu image to reduce the risk of downtime.

### Initialize and Apply Terraform

```bash
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    pushd contrib/terraform/exoscale
    terraform init
    terraform apply \
        -var-file=../../../inventory/$CLUSTER/default.tfvars \
        -state=../../../inventory/$CLUSTER/tfstate-$CLUSTER.tfstate
    cp inventory.ini ../../../inventory/$CLUSTER/
    popd
done
```

!!!important
    The Terraform state is stored in `inventory/$CLUSTER/tfstate-$CLUSTER.tfstate`, where `$CLUSTER` is the cluster name.
    It is precious. Consider backing it up or using [Terraform Cloud](https://www.terraform.io/docs/cloud/index.html).

You should now have inventory file named `inventory/$CLUSTER/inventory.ini` for each cluster that you can use with kubespray.

### Test access to all nodes

```bash
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    pushd inventory/$CLUSTER
    ANSIBLE_HOST_KEY_CHECKING=False ansible all -i inventory.ini -m ping
    popd
done
```

## Deploying vanilla Kubernetes clusters using Kubespray

With the infrastructure provisioned, we can now deploy Kubernetes using kubespray.
First, if you haven't done so already, install the pre-requisites and change to the `compliantkubernetes-kubespray` root directory.
```bash
pip3 install -r requirements.txt

cd ..
```

### Init the Kubespray config in your config path

```bash
export DOMAIN=<your_domain> # DNS domain to expose the services inside the service cluster i.e. "example.com"
export CK8S_CONFIG_PATH=~/.ck8s/exoscale
export CK8S_PGP_FP=<your GPG key fingerprint>  # retrieve with gpg --list-secret-keys

for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    ./bin/ck8s-kubespray init $CLUSTER default $CK8S_PGP_FP
done
```

### Copy the generated inventory files in the right location

Please copy the two inventory files, `kubespray/inventory/$CLUSTER/inventory.ini`, generated by Terraform to `${CK8S_CONFIG_PATH}/$CLUSTER-config/`, where $CLUSTER the name of each cluster (i.e., `testsc`, `testwc0`).

```
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    cp kubespray/inventory/$CLUSTER/inventory.ini ${CK8S_CONFIG_PATH}/$CLUSTER-config/
done
```
### Run kubespray to deploy the Kubernetes clusters

```bash
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    ./bin/ck8s-kubespray apply $CLUSTER --flush-cache
done
```
This may take up to 10 minutes for each cluster, 20 minutes in total.

### Correct the Kubernetes API IP addresses

Locate the encrypted kubeconfigs in `${CK8S_CONFIG_PATH}/.state/kube_config_*.yaml` and edit them using sops.
Copy the public IP address of the load balancer from inventory files `${CK8S_CONFIG_PATH}/*-config/inventory.ini` and replace the private IP address for the `server` field in `${CK8S_CONFIG_PATH}/.state/kube_config_*.yaml`.

```bash
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    sops ${CK8S_CONFIG_PATH}/.state/kube_config_$CLUSTER.yaml
done
```

### Test access to the clusters as follows

```bash
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    sops exec-file ${CK8S_CONFIG_PATH}/.state/kube_config_$CLUSTER.yaml \
        'kubectl --kubeconfig {} get nodes'
done
```

### Create the DNS Records

You will need to setup a number of DNS entries for traffic to be routed correctly.
Determine the public IP of the load-balancer fronting the Ingress controller of the clusters from the Terraform state file generated during infrastructure setup.

To get the load-balancer IP, run the following command:

```bash
SC_INGRESS_LB_IP_ADDRESS=$(terraform output -state kubespray/inventory/$SERVICE_CLUSTER/tfstate-$SERVICE_CLUSTER.tfstate -raw ingress_controller_lb_ip_address)
echo $SC_INGRESS_LB_IP_ADDRESS
```

Configure the exoscale CLI:

```
exo config
```

Then point these domains to the service cluster using 'exoscale cli' as follows:

```bash
exo dns add A $DOMAIN -a $SC_INGRESS_LB_IP_ADDRESS -n *.ops.$CK8S_ENVIRONMENT_NAME
exo dns add A $DOMAIN -a $SC_INGRESS_LB_IP_ADDRESS -n *.$CK8S_ENVIRONMENT_NAME
```

{%
   include-markdown "common.md"
   start="<!--deploy-rook-start-->"
   end="<!--deploy-rook-stop-->"
   comments=false
%}

{%
   include-markdown "common.md"
   start="<!--test-rook-start-->"
   end="<!--test-rook-stop-->"
   comments=false
%}

## Deploying Compliant Kubernetes Apps

{%
   include-markdown "common.md"
   start="<!--clone-apps-start-->"
   end="<!--clone-apps-stop-->"
   comments=false
%}

{%
   include-markdown "common.md"
   start="<!--init-apps-start-->"
   end="<!--init-apps-stop-->"
   comments=false
%}

{%
   include-markdown "common.md"
   start="<!--configure-apps-start-->"
   end="<!--configure-apps-stop-->"
   comments=false
%}

The following are the minimum change you should perform:

```yaml
# ${CK8S_CONFIG_PATH}/sc-config.yaml and ${CK8S_CONFIG_PATH}/wc-config.yaml
global:
  baseDomain: set-me # set to $CK8S_ENVIRONMENT_NAME.$DOMAIN
  opsDomain: set-me  # set to ops.$CK8S_ENVIRONMENT_NAME.$DOMAIN
  issuer: letsencrypt-prod

objectStorage:
  # type: s3 # set as default for prod flavor, defaults to "none" for dev
  s3:
    region: set-me          # Region for S3 buckets, e.g. ch-gva-2
    regionEndpoint: set-me  # Region endpoint for S3 buckets, e.g. https://sos-ch-gva-2.exo.io
    # forcePathStyle: false # set as default

clusterAdmin:
  users: # set to the cluster admin users
    - set-me
    - admin@example.com
```

```yaml
# ${CK8S_CONFIG_PATH}/sc-config.yaml (in addition to the changes above)
user:
  grafana:
    oidc:
      allowedDomains: # set to your domain(s), or unset using [] to deny all
        - set-me
        - example.com
harbor:
  # persistence:
  #  type: objectStorage    # set as default for prod flavor, defaults to "filesystem" for dev
  #  disableRedirect: false # set as default
  oidc:
    groupClaimName: set-me # set to group claim name used by OIDC provider
    adminGroupName: set-me # name of the group that automatically will get admin

elasticsearch:
  extraRoleMappings: # set to configure elasticsearch access, or unset using []
    - mapping_name: kibana_user
      definition:
        users:
          - set-me
    - mapping_name: kubernetes_log_reader
      definition:
        users:
          - set-me
    - mapping_name: all_access
      definition:
        users:
          - set-me

alerts:
  opsGenieHeartbeat:
    # enabled: true # set as default for prod flavour, defaults to "false" for dev
    name: set-me    # set to name the heartbeat if enabled

issuers:
  letsencrypt:
    prod:
      email: set-me # set this to an email to receive LetsEncrypt notifications
    staging:
      email: set-me # set this to an email to receive LetsEncrypt notifications
```

```yaml
# ${CK8S_CONFIG_PATH}/wc-config.yaml (in addition to the changes above)
user:
  namespaces: # set this to create user namespaces, or unset using []
    - set-me
    - production
    - staging
  adminUsers: # set this to create admins in the user namespaces, or unset using []
    - set-me
    - admin@example.com
  adminGroups: # set this to create admin groups in the user namespaces, or unset using []
    - set-me
  # alertmanager: # add this block to enable user accessible alertmanager
  #   enabled: true
  #   namespace: alertmanager # note that this namespace must be listed above under "user.namespaces"

opa:
  imageRegistry:
    URL: # set this to the allowed image registry, or unset using [] to deny all
      - set-me
      - harbor.example.com
```

```yaml
# ${CK8S_CONFIG_PATH}/secrets.yaml
objectStorage:
  s3:
    accessKey: set-me # set to your s3 accesskey
    secretKey: set-me # set to your s3 secretKey
```

{%
   include-markdown "common.md"
   start="<!--create-s3-buckets-start-->"
   end="<!--create-s3-buckets-stop-->"
   comments=false
%}

{%
   include-markdown "common.md"
   start="<!--test-s3-buckets-start-->"
   end="<!--test-s3-buckets-stop-->"
   comments=false
%}

{%
   include-markdown "common.md"
   start="<!--install-apps-start-->"
   end="<!--install-apps-stop-->"
   comments=false
%}

{%
   include-markdown "common.md"
   start="<!--settling-start-->"
   end="<!--settling-stop-->"
   comments=false
%}

{%
   include-markdown "common.md"
   start="<!--testing-start-->"
   end="<!--testing-stop-->"
   comments=false
%}

## Teardown

{%
   include-markdown "common.md"
   start="<!--clean-apps-start-->"
   end="<!--clean-apps-stop-->"
   comments=false
%}

### Remove infrastructure

To teardown the infrastructure, please switch to the root directory of the exoscale branch of the Kubespray repo (see the Terraform section).

```bash
for CLUSTER in ${SERVICE_CLUSTER} "${WORKLOAD_CLUSTERS[@]}"; do
    pushd contrib/terraform/exoscale
    terraform init
    terraform destroy \
        -var-file=../../../inventory/$CLUSTER/default.tfvars \
        -state=../../../inventory/$CLUSTER/tfstate-$CLUSTER.tfstate
    popd
done

# Remove DNS records
exo dns remove $DOMAIN *.ops.$CK8S_ENVIRONMENT_NAME
exo dns remove $DOMAIN *.$CK8S_ENVIRONMENT_NAME
```

## Further Reading

* [Elastisys Compliant Kubernetes Kubespray](https://github.com/elastisys/compliantkubernetes-kubespray/blob/main/README.md)
* [Kubernetes on Exoscale with Terraform](https://github.com/elastisys/kubespray/tree/exoscale/contrib/terraform/exoscale)
* [Compliant Kubernetes apps repo](https://github.com/elastisys/compliantkubernetes-apps)
* [Configurations option](https://github.com/elastisys/compliantkubernetes-apps#elastisys-compliant-kubernetes-apps)
